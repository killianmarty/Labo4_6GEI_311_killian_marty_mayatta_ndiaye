\doxysection{flask.\+sessions.\+Session\+Interface Class Reference}
\hypertarget{classflask_1_1sessions_1_1_session_interface}{}\label{classflask_1_1sessions_1_1_session_interface}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
Inheritance diagram for flask.\+sessions.\+Session\+Interface\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classflask_1_1sessions_1_1_session_interface}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classflask_1_1sessions_1_1_null_session}{Null\+Session}} \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_af4fe5c30953c6f47270af2fb10da0123}{make\+\_\+null\+\_\+session}} (self, "{}Flask"{} app)
\item 
bool \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_a5cd8b16ff34fb29575140e8e0fe9fb82}{is\+\_\+null\+\_\+session}} (self, object obj)
\item 
str \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_a59320705cfd52bb0ba216860374ecda7}{get\+\_\+cookie\+\_\+name}} (self, "{}Flask"{} app)
\item 
t.\+Optional\mbox{[}str\mbox{]} \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_ac8fa54b4b3903b002de2cbb68cf180d8}{get\+\_\+cookie\+\_\+domain}} (self, "{}Flask"{} app)
\item 
str \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_a587a1bf3b037dcde52a2c3e4144322ee}{get\+\_\+cookie\+\_\+path}} (self, "{}Flask"{} app)
\item 
bool \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_aaa410cc64b1698b378d4e009b658207c}{get\+\_\+cookie\+\_\+httponly}} (self, "{}Flask"{} app)
\item 
bool \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_ad73f88643f9c522081c120577552f670}{get\+\_\+cookie\+\_\+secure}} (self, "{}Flask"{} app)
\item 
str \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_ab1cc2797f5244a3faa00a2608d22c871}{get\+\_\+cookie\+\_\+samesite}} (self, "{}Flask"{} app)
\item 
t.\+Optional\mbox{[}datetime\mbox{]} \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_ac6f46ba4930cd934e108d076f9259f8d}{get\+\_\+expiration\+\_\+time}} (self, "{}Flask"{} app, \mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}} session)
\item 
bool \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_ac01ecd8506f4ac72041997f606df9f87}{should\+\_\+set\+\_\+cookie}} (self, "{}Flask"{} app, \mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}} session)
\item 
t.\+Optional\mbox{[}\mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}}\mbox{]} \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_acbf3ca5383f819e0ac34e101a8d2cdf0}{open\+\_\+session}} (self, "{}Flask"{} app, "{}Request"{} request)
\item 
None \mbox{\hyperlink{classflask_1_1sessions_1_1_session_interface_a04b4e74583ef42c85b837d034aa20cfc}{save\+\_\+session}} (self, "{}Flask"{} app, \mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}} session, "{}Response"{} response)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classflask_1_1sessions_1_1_session_interface_a9bce187004bb38c8ad5ec63fc5eaad79}\label{classflask_1_1sessions_1_1_session_interface_a9bce187004bb38c8ad5ec63fc5eaad79} 
{\bfseries null\+\_\+session\+\_\+class} = \mbox{\hyperlink{classflask_1_1sessions_1_1_null_session}{Null\+Session}}
\item 
\Hypertarget{classflask_1_1sessions_1_1_session_interface_a6b9a195f202efc7b51bf5f45f61539ee}\label{classflask_1_1sessions_1_1_session_interface_a6b9a195f202efc7b51bf5f45f61539ee} 
bool {\bfseries pickle\+\_\+based} = False
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}The basic interface you have to implement in order to replace the
default session interface which uses werkzeug's securecookie
implementation.  The only methods you have to implement are
:meth:`open_session` and :meth:`save_session`, the others have
useful defaults which you don't need to change.

The session object returned by the :meth:`open_session` method has to
provide a dictionary like interface plus the properties and methods
from the :class:`SessionMixin`.  We recommend just subclassing a dict
and adding that mixin::

    class Session(dict, SessionMixin):
        pass

If :meth:`open_session` returns ``None`` Flask will call into
:meth:`make_null_session` to create a session that acts as replacement
if the session support cannot work because some requirement is not
fulfilled.  The default :class:`NullSession` class that is created
will complain that the secret key was not set.

To replace the session interface on an application all you have to do
is to assign :attr:`flask.Flask.session_interface`::

    app = Flask(__name__)
    app.session_interface = MySessionInterface()

Multiple requests with the same session may be sent and handled
concurrently. When implementing a new session interface, consider
whether reads or writes to the backing store must be synchronized.
There is no guarantee on the order in which the session for each
request is opened or saved, it will occur in the order that requests
begin and end processing.

.. versionadded:: 0.8
\end{DoxyVerb}
 

\doxysubsection{Member Function Documentation}
\Hypertarget{classflask_1_1sessions_1_1_session_interface_ac8fa54b4b3903b002de2cbb68cf180d8}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_domain@{get\_cookie\_domain}}
\index{get\_cookie\_domain@{get\_cookie\_domain}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_domain()}{get\_cookie\_domain()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_ac8fa54b4b3903b002de2cbb68cf180d8} 
 t.\+Optional\mbox{[}str\mbox{]} flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+domain (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the domain that should be set for the session cookie.

Uses ``SESSION_COOKIE_DOMAIN`` if it is configured, otherwise
falls back to detecting the domain based on ``SERVER_NAME``.

Once detected (or if not set at all), ``SESSION_COOKIE_DOMAIN`` is
updated to avoid re-running the logic.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_aaa410cc64b1698b378d4e009b658207c}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_httponly@{get\_cookie\_httponly}}
\index{get\_cookie\_httponly@{get\_cookie\_httponly}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_httponly()}{get\_cookie\_httponly()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_aaa410cc64b1698b378d4e009b658207c} 
 bool flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+httponly (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if the session cookie should be httponly.  This
currently just returns the value of the ``SESSION_COOKIE_HTTPONLY``
config var.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_a59320705cfd52bb0ba216860374ecda7}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_name@{get\_cookie\_name}}
\index{get\_cookie\_name@{get\_cookie\_name}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_name()}{get\_cookie\_name()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_a59320705cfd52bb0ba216860374ecda7} 
 str flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+name (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}The name of the session cookie. Uses``app.config["SESSION_COOKIE_NAME"]``.\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_a587a1bf3b037dcde52a2c3e4144322ee}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_path@{get\_cookie\_path}}
\index{get\_cookie\_path@{get\_cookie\_path}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_path()}{get\_cookie\_path()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_a587a1bf3b037dcde52a2c3e4144322ee} 
 str flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+path (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the path for which the cookie should be valid.  The
default implementation uses the value from the ``SESSION_COOKIE_PATH``
config var if it's set, and falls back to ``APPLICATION_ROOT`` or
uses ``/`` if it's ``None``.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_ab1cc2797f5244a3faa00a2608d22c871}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_samesite@{get\_cookie\_samesite}}
\index{get\_cookie\_samesite@{get\_cookie\_samesite}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_samesite()}{get\_cookie\_samesite()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_ab1cc2797f5244a3faa00a2608d22c871} 
 str flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+samesite (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return ``'Strict'`` or ``'Lax'`` if the cookie should use the
``SameSite`` attribute. This currently just returns the value of
the :data:`SESSION_COOKIE_SAMESITE` setting.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_ad73f88643f9c522081c120577552f670}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_cookie\_secure@{get\_cookie\_secure}}
\index{get\_cookie\_secure@{get\_cookie\_secure}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_cookie\_secure()}{get\_cookie\_secure()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_ad73f88643f9c522081c120577552f670} 
 bool flask.\+sessions.\+Session\+Interface.\+get\+\_\+cookie\+\_\+secure (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns True if the cookie should be secure.  This currently
just returns the value of the ``SESSION_COOKIE_SECURE`` setting.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_ac6f46ba4930cd934e108d076f9259f8d}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!get\_expiration\_time@{get\_expiration\_time}}
\index{get\_expiration\_time@{get\_expiration\_time}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{get\_expiration\_time()}{get\_expiration\_time()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_ac6f46ba4930cd934e108d076f9259f8d} 
 t.\+Optional\mbox{[}datetime\mbox{]} flask.\+sessions.\+Session\+Interface.\+get\+\_\+expiration\+\_\+time (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{, }\item[{\mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}}     }]{session}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}A helper method that returns an expiration date for the session
or ``None`` if the session is linked to the browser session.  The
default implementation returns now + the permanent session
lifetime configured on the application.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_a5cd8b16ff34fb29575140e8e0fe9fb82}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!is\_null\_session@{is\_null\_session}}
\index{is\_null\_session@{is\_null\_session}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{is\_null\_session()}{is\_null\_session()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_a5cd8b16ff34fb29575140e8e0fe9fb82} 
 bool flask.\+sessions.\+Session\+Interface.\+is\+\_\+null\+\_\+session (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{object}]{obj}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Checks if a given object is a null session.  Null sessions are
not asked to be saved.

This checks if the object is an instance of :attr:`null_session_class`
by default.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_af4fe5c30953c6f47270af2fb10da0123}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!make\_null\_session@{make\_null\_session}}
\index{make\_null\_session@{make\_null\_session}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{make\_null\_session()}{make\_null\_session()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_af4fe5c30953c6f47270af2fb10da0123} 
 \mbox{\hyperlink{classflask_1_1sessions_1_1_null_session}{Null\+Session}} flask.\+sessions.\+Session\+Interface.\+make\+\_\+null\+\_\+session (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Creates a null session which acts as a replacement object if the
real session support could not be loaded due to a configuration
error.  This mainly aids the user experience because the job of the
null session is to still support lookup without complaining but
modifications are answered with a helpful error message of what
failed.

This creates an instance of :attr:`null_session_class` by default.
\end{DoxyVerb}
 \Hypertarget{classflask_1_1sessions_1_1_session_interface_acbf3ca5383f819e0ac34e101a8d2cdf0}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!open\_session@{open\_session}}
\index{open\_session@{open\_session}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{open\_session()}{open\_session()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_acbf3ca5383f819e0ac34e101a8d2cdf0} 
 t.\+Optional\mbox{[}\mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}}\mbox{]} flask.\+sessions.\+Session\+Interface.\+open\+\_\+session (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{, }\item[{"{}Request"{}     }]{request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}This is called at the beginning of each request, after
pushing the request context, before matching the URL.

This must return an object which implements a dictionary-like
interface as well as the :class:`SessionMixin` interface.

This will return ``None`` to indicate that loading failed in
some way that is not immediately an error. The request
context will fall back to using :meth:`make_null_session`
in this case.
\end{DoxyVerb}
 

Reimplemented in \mbox{\hyperlink{classflask_1_1sessions_1_1_secure_cookie_session_interface_a6802d02f5cd24d708de6c65bf3b23a41}{flask.\+sessions.\+Secure\+Cookie\+Session\+Interface}}.

\Hypertarget{classflask_1_1sessions_1_1_session_interface_a04b4e74583ef42c85b837d034aa20cfc}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!save\_session@{save\_session}}
\index{save\_session@{save\_session}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{save\_session()}{save\_session()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_a04b4e74583ef42c85b837d034aa20cfc} 
 None flask.\+sessions.\+Session\+Interface.\+save\+\_\+session (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{, }\item[{\mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}}}]{session}{, }\item[{"{}Response"{}     }]{response}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}This is called at the end of each request, after generating
a response, before removing the request context. It is skipped
if :meth:`is_null_session` returns ``True``.
\end{DoxyVerb}
 

Reimplemented in \mbox{\hyperlink{classflask_1_1sessions_1_1_secure_cookie_session_interface_a4c612012bfc0a10aa310d59569db3ab0}{flask.\+sessions.\+Secure\+Cookie\+Session\+Interface}}.

\Hypertarget{classflask_1_1sessions_1_1_session_interface_ac01ecd8506f4ac72041997f606df9f87}\index{flask.sessions.SessionInterface@{flask.sessions.SessionInterface}!should\_set\_cookie@{should\_set\_cookie}}
\index{should\_set\_cookie@{should\_set\_cookie}!flask.sessions.SessionInterface@{flask.sessions.SessionInterface}}
\doxysubsubsection{\texorpdfstring{should\_set\_cookie()}{should\_set\_cookie()}}
{\footnotesize\ttfamily \label{classflask_1_1sessions_1_1_session_interface_ac01ecd8506f4ac72041997f606df9f87} 
 bool flask.\+sessions.\+Session\+Interface.\+should\+\_\+set\+\_\+cookie (\begin{DoxyParamCaption}\item[{}]{self}{, }\item[{"{}Flask"{}}]{app}{, }\item[{\mbox{\hyperlink{classflask_1_1sessions_1_1_session_mixin}{Session\+Mixin}}}]{session}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Used by session backends to determine if a ``Set-Cookie`` header
should be set for this session cookie for this response. If the session
has been modified, the cookie is set. If the session is permanent and
the ``SESSION_REFRESH_EACH_REQUEST`` config is true, the cookie is
always set.

This check is usually skipped if the session was deleted.

.. versionadded:: 0.11
\end{DoxyVerb}
 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
C\+:/\+Users/kmarty/\+Documents/\+Labo3\+\_\+architecture\+\_\+killian\+\_\+marty/\+Lib/site-\/packages/flask/sessions.\+py\end{DoxyCompactItemize}
