\doxysection{requests.\+utils Namespace Reference}
\hypertarget{namespacerequests_1_1utils}{}\label{namespacerequests_1_1utils}\index{requests.utils@{requests.utils}}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespacerequests_1_1utils_a908c2a19d521fdcb1e4ffa842f15465e}\label{namespacerequests_1_1utils_a908c2a19d521fdcb1e4ffa842f15465e} 
{\bfseries proxy\+\_\+bypass\+\_\+registry} (host)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_afa6029e54432c133cf4b40e0083d93f7}{proxy\+\_\+bypass}} (host)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ac34622b1fb368c217644c58605b9d34f}{dict\+\_\+to\+\_\+sequence}} (d)
\item 
\Hypertarget{namespacerequests_1_1utils_a62b384899cbabfdedb78e1ff0e2edf5b}\label{namespacerequests_1_1utils_a62b384899cbabfdedb78e1ff0e2edf5b} 
{\bfseries super\+\_\+len} (o)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a6af467cfc4643a7672d11895f6e2d641}{get\+\_\+netrc\+\_\+auth}} (url, raise\+\_\+errors=False)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a68e1732d3715206da30bef56fe8f589e}{guess\+\_\+filename}} (obj)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a3c66e1b595b893718f1c3bf9749ef940}{extract\+\_\+zipped\+\_\+paths}} (path)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a8331ad2e81a91c6dd326a8a5f6a81ec5}{atomic\+\_\+open}} (filename)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ae71b8ecccdfa136d1e38c0ec17679df8}{from\+\_\+key\+\_\+val\+\_\+list}} (value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a6ea8cc24a110e6f447baef613013907f}{to\+\_\+key\+\_\+val\+\_\+list}} (value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ad3725c94c4c8a284639724d31808d720}{parse\+\_\+list\+\_\+header}} (value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_af138777b022e18c3a92b507b35fd0efb}{parse\+\_\+dict\+\_\+header}} (value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a38d24d784c3fdf1711d7d427fee93954}{unquote\+\_\+header\+\_\+value}} (value, is\+\_\+filename=False)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a180ebb9cf0826a0122ff5de498813da9}{dict\+\_\+from\+\_\+cookiejar}} (cj)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a175ff860a75d93836fb81c8ff299d13e}{add\+\_\+dict\+\_\+to\+\_\+cookiejar}} (cj, cookie\+\_\+dict)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a47affe42ed0ac90c45665688111d0ded}{get\+\_\+encodings\+\_\+from\+\_\+content}} (content)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a952daab01ac92fad64fbbeb3383ce8e3}{\+\_\+parse\+\_\+content\+\_\+type\+\_\+header}} (header)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a05b3c685cba92aba2abfe3818fe3b4f9}{get\+\_\+encoding\+\_\+from\+\_\+headers}} (headers)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ad8bca5e2a573cb2f2abd8b7ac931e693}{stream\+\_\+decode\+\_\+response\+\_\+unicode}} (iterator, r)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a736a580686e4c56ad9839e130e4e9275}{iter\+\_\+slices}} (string, slice\+\_\+length)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a7121ab33bc10527c8aca7bb7f5ef895d}{get\+\_\+unicode\+\_\+from\+\_\+response}} (r)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a4f9754a15bf861194570d75e1863381b}{unquote\+\_\+unreserved}} (uri)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a8c9fe3c9ac2bd12a800447169e0e0670}{requote\+\_\+uri}} (uri)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a91f3c27c14f113a6677acef8d4f0c8c4}{address\+\_\+in\+\_\+network}} (ip, net)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a5b7551c2fa933fd956dcf921b7c8df71}{dotted\+\_\+netmask}} (mask)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a0032596bcde59652ed82002e1d2e54b6}{is\+\_\+ipv4\+\_\+address}} (string\+\_\+ip)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_aaa928b4720b9ef7f9ac2bf782261f678}{is\+\_\+valid\+\_\+cidr}} (string\+\_\+network)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a5d285ca80bd58e70e828532e7d2f6ebf}{set\+\_\+environ}} (env\+\_\+name, value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a7be3a56db1500d1c5c79db4e8884a018}{should\+\_\+bypass\+\_\+proxies}} (url, no\+\_\+proxy)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ac23afb196fec8b059ed1a03595806791}{get\+\_\+environ\+\_\+proxies}} (url, no\+\_\+proxy=None)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_adf045a28323bbaaac6de35c6d69ba2cc}{select\+\_\+proxy}} (url, proxies)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a0512e3f1e64d904b7e01e7fc8efcaf0d}{resolve\+\_\+proxies}} (request, proxies, trust\+\_\+env=True)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a1e99c69956cd21b5897bdfcf1c0fc540}{default\+\_\+user\+\_\+agent}} (name="{}python-\/requests"{})
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_adb277c6c9453f4d4df66abdd3ec3ad05}{default\+\_\+headers}} ()
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ab50769584f88302aab3bad1bbbbc446a}{parse\+\_\+header\+\_\+links}} (value)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a5ab5bd841aa4c2f7f1de7116681fdc0b}{guess\+\_\+json\+\_\+utf}} (data)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a13469939a631c81a773c8acb2fb9f363}{prepend\+\_\+scheme\+\_\+if\+\_\+needed}} (url, new\+\_\+scheme)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ac97def7be462f0599dbef8b2f4859056}{get\+\_\+auth\+\_\+from\+\_\+url}} (url)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a80e2cfa297e346be2c66cbae223c7376}{check\+\_\+header\+\_\+validity}} (header)
\item 
\Hypertarget{namespacerequests_1_1utils_a77e11ecb8d94065be2d4d414f61c40aa}\label{namespacerequests_1_1utils_a77e11ecb8d94065be2d4d414f61c40aa} 
{\bfseries \+\_\+validate\+\_\+header\+\_\+part} (header, header\+\_\+part, header\+\_\+validator\+\_\+index)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_ad5cd90b7dfae5b0d9809ef0d52ad1ff7}{urldefragauth}} (url)
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a13215bbc71180ebbe86f99999bdd0b8c}{rewind\+\_\+body}} (prepared\+\_\+request)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespacerequests_1_1utils_abc02efcf84cc31b6cac190cce3981f90}\label{namespacerequests_1_1utils_abc02efcf84cc31b6cac190cce3981f90} 
tuple {\bfseries NETRC\+\_\+\+FILES} = ("{}.netrc"{}, "{}\+\_\+netrc"{})
\item 
\Hypertarget{namespacerequests_1_1utils_a34718944359129147da929ba2019100f}\label{namespacerequests_1_1utils_a34718944359129147da929ba2019100f} 
{\bfseries DEFAULT\+\_\+\+CA\+\_\+\+BUNDLE\+\_\+\+PATH} = certs.\+where()
\item 
\Hypertarget{namespacerequests_1_1utils_a1bfc6edb8670d42a0b9e4ec43201290e}\label{namespacerequests_1_1utils_a1bfc6edb8670d42a0b9e4ec43201290e} 
dict {\bfseries DEFAULT\+\_\+\+PORTS} = \{"{}http"{}\+: 80, "{}https"{}\+: 443\}
\item 
str \mbox{\hyperlink{namespacerequests_1_1utils_abcced58e9e5e747662c683f7a8a91678}{DEFAULT\+\_\+\+ACCEPT\+\_\+\+ENCODING}}
\item 
\mbox{\hyperlink{namespacerequests_1_1utils_a06db2df65ac89013c3f98efa6d00bd1a}{UNRESERVED\+\_\+\+SET}}
\item 
\Hypertarget{namespacerequests_1_1utils_a667e9639106ba40bc417be24314dcbd9}\label{namespacerequests_1_1utils_a667e9639106ba40bc417be24314dcbd9} 
str {\bfseries \+\_\+null} = "{}\textbackslash{}x00"{}.\+encode("{}ascii"{})
\item 
\Hypertarget{namespacerequests_1_1utils_a355fd1a0e14b83a13bceb7d9ebfbb1b3}\label{namespacerequests_1_1utils_a355fd1a0e14b83a13bceb7d9ebfbb1b3} 
str {\bfseries \+\_\+null2} = \+\_\+null \texorpdfstring{$\ast$}{*} 2
\item 
\Hypertarget{namespacerequests_1_1utils_a4d1f22ff69403c111d3eb510a422ed9c}\label{namespacerequests_1_1utils_a4d1f22ff69403c111d3eb510a422ed9c} 
str {\bfseries \+\_\+null3} = \+\_\+null \texorpdfstring{$\ast$}{*} 3
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}requests.utils
~~~~~~~~~~~~~~

This module provides utility functions that are used within Requests
that are also useful for external consumption.
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacerequests_1_1utils_a952daab01ac92fad64fbbeb3383ce8e3}\index{requests.utils@{requests.utils}!\_parse\_content\_type\_header@{\_parse\_content\_type\_header}}
\index{\_parse\_content\_type\_header@{\_parse\_content\_type\_header}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{\_parse\_content\_type\_header()}{\_parse\_content\_type\_header()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a952daab01ac92fad64fbbeb3383ce8e3} 
requests.\+utils.\+\_\+parse\+\_\+content\+\_\+type\+\_\+header (\begin{DoxyParamCaption}\item[{}]{header}{}\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}}

\begin{DoxyVerb}Returns content type and parameters from given header

:param header: string
:return: tuple containing content type and dictionary of
     parameters
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a175ff860a75d93836fb81c8ff299d13e}\index{requests.utils@{requests.utils}!add\_dict\_to\_cookiejar@{add\_dict\_to\_cookiejar}}
\index{add\_dict\_to\_cookiejar@{add\_dict\_to\_cookiejar}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{add\_dict\_to\_cookiejar()}{add\_dict\_to\_cookiejar()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a175ff860a75d93836fb81c8ff299d13e} 
requests.\+utils.\+add\+\_\+dict\+\_\+to\+\_\+cookiejar (\begin{DoxyParamCaption}\item[{}]{cj}{, }\item[{}]{cookie\+\_\+dict}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a CookieJar from a key/value dictionary.

:param cj: CookieJar to insert cookies into.
:param cookie_dict: Dict of key/values to insert into CookieJar.
:rtype: CookieJar
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a91f3c27c14f113a6677acef8d4f0c8c4}\index{requests.utils@{requests.utils}!address\_in\_network@{address\_in\_network}}
\index{address\_in\_network@{address\_in\_network}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{address\_in\_network()}{address\_in\_network()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a91f3c27c14f113a6677acef8d4f0c8c4} 
requests.\+utils.\+address\+\_\+in\+\_\+network (\begin{DoxyParamCaption}\item[{}]{ip}{, }\item[{}]{net}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}This function allows you to check if an IP belongs to a network subnet

Example: returns True if ip = 192.168.1.1 and net = 192.168.1.0/24
         returns False if ip = 192.168.1.1 and net = 192.168.100.0/24

:rtype: bool
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a8331ad2e81a91c6dd326a8a5f6a81ec5}\index{requests.utils@{requests.utils}!atomic\_open@{atomic\_open}}
\index{atomic\_open@{atomic\_open}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{atomic\_open()}{atomic\_open()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a8331ad2e81a91c6dd326a8a5f6a81ec5} 
requests.\+utils.\+atomic\+\_\+open (\begin{DoxyParamCaption}\item[{}]{filename}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Write a file to the disk in an atomic fashion\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a80e2cfa297e346be2c66cbae223c7376}\index{requests.utils@{requests.utils}!check\_header\_validity@{check\_header\_validity}}
\index{check\_header\_validity@{check\_header\_validity}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{check\_header\_validity()}{check\_header\_validity()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a80e2cfa297e346be2c66cbae223c7376} 
requests.\+utils.\+check\+\_\+header\+\_\+validity (\begin{DoxyParamCaption}\item[{}]{header}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Verifies that header parts don't contain leading whitespace
reserved characters, or return characters.

:param header: tuple, in the format (name, value).
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_adb277c6c9453f4d4df66abdd3ec3ad05}\index{requests.utils@{requests.utils}!default\_headers@{default\_headers}}
\index{default\_headers@{default\_headers}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{default\_headers()}{default\_headers()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_adb277c6c9453f4d4df66abdd3ec3ad05} 
requests.\+utils.\+default\+\_\+headers (\begin{DoxyParamCaption}{}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: requests.structures.CaseInsensitiveDict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a1e99c69956cd21b5897bdfcf1c0fc540}\index{requests.utils@{requests.utils}!default\_user\_agent@{default\_user\_agent}}
\index{default\_user\_agent@{default\_user\_agent}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{default\_user\_agent()}{default\_user\_agent()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a1e99c69956cd21b5897bdfcf1c0fc540} 
requests.\+utils.\+default\+\_\+user\+\_\+agent (\begin{DoxyParamCaption}\item[{}]{name}{ = {\ttfamily "{}python-\/requests"{}}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a string representing the default user agent.

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a180ebb9cf0826a0122ff5de498813da9}\index{requests.utils@{requests.utils}!dict\_from\_cookiejar@{dict\_from\_cookiejar}}
\index{dict\_from\_cookiejar@{dict\_from\_cookiejar}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dict\_from\_cookiejar()}{dict\_from\_cookiejar()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a180ebb9cf0826a0122ff5de498813da9} 
requests.\+utils.\+dict\+\_\+from\+\_\+cookiejar (\begin{DoxyParamCaption}\item[{}]{cj}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns a key/value dictionary from a CookieJar.

:param cj: CookieJar object to extract cookies from.
:rtype: dict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ac34622b1fb368c217644c58605b9d34f}\index{requests.utils@{requests.utils}!dict\_to\_sequence@{dict\_to\_sequence}}
\index{dict\_to\_sequence@{dict\_to\_sequence}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dict\_to\_sequence()}{dict\_to\_sequence()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ac34622b1fb368c217644c58605b9d34f} 
requests.\+utils.\+dict\+\_\+to\+\_\+sequence (\begin{DoxyParamCaption}\item[{}]{d}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns an internal sequence dictionary update.\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a5b7551c2fa933fd956dcf921b7c8df71}\index{requests.utils@{requests.utils}!dotted\_netmask@{dotted\_netmask}}
\index{dotted\_netmask@{dotted\_netmask}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{dotted\_netmask()}{dotted\_netmask()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a5b7551c2fa933fd956dcf921b7c8df71} 
requests.\+utils.\+dotted\+\_\+netmask (\begin{DoxyParamCaption}\item[{}]{mask}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Converts mask from /xx format to xxx.xxx.xxx.xxx

Example: if mask is 24 function returns 255.255.255.0

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a3c66e1b595b893718f1c3bf9749ef940}\index{requests.utils@{requests.utils}!extract\_zipped\_paths@{extract\_zipped\_paths}}
\index{extract\_zipped\_paths@{extract\_zipped\_paths}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{extract\_zipped\_paths()}{extract\_zipped\_paths()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a3c66e1b595b893718f1c3bf9749ef940} 
requests.\+utils.\+extract\+\_\+zipped\+\_\+paths (\begin{DoxyParamCaption}\item[{}]{path}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Replace nonexistent paths that look like they refer to a member of a zip
archive with the location of an extracted copy of the target, or else
just return the provided path unchanged.
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ae71b8ecccdfa136d1e38c0ec17679df8}\index{requests.utils@{requests.utils}!from\_key\_val\_list@{from\_key\_val\_list}}
\index{from\_key\_val\_list@{from\_key\_val\_list}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{from\_key\_val\_list()}{from\_key\_val\_list()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ae71b8ecccdfa136d1e38c0ec17679df8} 
requests.\+utils.\+from\+\_\+key\+\_\+val\+\_\+list (\begin{DoxyParamCaption}\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Take an object and test to see if it can be represented as a
dictionary. Unless it can not be represented as such, return an
OrderedDict, e.g.,

::

    >>> from_key_val_list([('key', 'val')])
    OrderedDict([('key', 'val')])
    >>> from_key_val_list('string')
    Traceback (most recent call last):
    ...
    ValueError: cannot encode objects that are not 2-tuples
    >>> from_key_val_list({'key': 'val'})
    OrderedDict([('key', 'val')])

:rtype: OrderedDict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ac97def7be462f0599dbef8b2f4859056}\index{requests.utils@{requests.utils}!get\_auth\_from\_url@{get\_auth\_from\_url}}
\index{get\_auth\_from\_url@{get\_auth\_from\_url}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_auth\_from\_url()}{get\_auth\_from\_url()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ac97def7be462f0599dbef8b2f4859056} 
requests.\+utils.\+get\+\_\+auth\+\_\+from\+\_\+url (\begin{DoxyParamCaption}\item[{}]{url}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a url with authentication components, extract them into a tuple of
username,password.

:rtype: (str,str)
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a05b3c685cba92aba2abfe3818fe3b4f9}\index{requests.utils@{requests.utils}!get\_encoding\_from\_headers@{get\_encoding\_from\_headers}}
\index{get\_encoding\_from\_headers@{get\_encoding\_from\_headers}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_encoding\_from\_headers()}{get\_encoding\_from\_headers()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a05b3c685cba92aba2abfe3818fe3b4f9} 
requests.\+utils.\+get\+\_\+encoding\+\_\+from\+\_\+headers (\begin{DoxyParamCaption}\item[{}]{headers}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns encodings from given HTTP Header Dict.

:param headers: dictionary to extract encoding from.
:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a47affe42ed0ac90c45665688111d0ded}\index{requests.utils@{requests.utils}!get\_encodings\_from\_content@{get\_encodings\_from\_content}}
\index{get\_encodings\_from\_content@{get\_encodings\_from\_content}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_encodings\_from\_content()}{get\_encodings\_from\_content()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a47affe42ed0ac90c45665688111d0ded} 
requests.\+utils.\+get\+\_\+encodings\+\_\+from\+\_\+content (\begin{DoxyParamCaption}\item[{}]{content}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns encodings from given content string.

:param content: bytestring to extract encodings from.
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ac23afb196fec8b059ed1a03595806791}\index{requests.utils@{requests.utils}!get\_environ\_proxies@{get\_environ\_proxies}}
\index{get\_environ\_proxies@{get\_environ\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_environ\_proxies()}{get\_environ\_proxies()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ac23afb196fec8b059ed1a03595806791} 
requests.\+utils.\+get\+\_\+environ\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{url}{, }\item[{}]{no\+\_\+proxy}{ = {\ttfamily None}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a dict of environment proxies.

:rtype: dict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a6af467cfc4643a7672d11895f6e2d641}\index{requests.utils@{requests.utils}!get\_netrc\_auth@{get\_netrc\_auth}}
\index{get\_netrc\_auth@{get\_netrc\_auth}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_netrc\_auth()}{get\_netrc\_auth()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a6af467cfc4643a7672d11895f6e2d641} 
requests.\+utils.\+get\+\_\+netrc\+\_\+auth (\begin{DoxyParamCaption}\item[{}]{url}{, }\item[{}]{raise\+\_\+errors}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the Requests tuple auth for a given url from netrc.\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a7121ab33bc10527c8aca7bb7f5ef895d}\index{requests.utils@{requests.utils}!get\_unicode\_from\_response@{get\_unicode\_from\_response}}
\index{get\_unicode\_from\_response@{get\_unicode\_from\_response}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{get\_unicode\_from\_response()}{get\_unicode\_from\_response()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a7121ab33bc10527c8aca7bb7f5ef895d} 
requests.\+utils.\+get\+\_\+unicode\+\_\+from\+\_\+response (\begin{DoxyParamCaption}\item[{}]{r}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns the requested content back in unicode.

:param r: Response object to get unicode content from.

Tried:

1. charset from content-type
2. fall back and replace all unicode characters

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a68e1732d3715206da30bef56fe8f589e}\index{requests.utils@{requests.utils}!guess\_filename@{guess\_filename}}
\index{guess\_filename@{guess\_filename}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{guess\_filename()}{guess\_filename()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a68e1732d3715206da30bef56fe8f589e} 
requests.\+utils.\+guess\+\_\+filename (\begin{DoxyParamCaption}\item[{}]{obj}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Tries to guess the filename of the given object.\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a5ab5bd841aa4c2f7f1de7116681fdc0b}\index{requests.utils@{requests.utils}!guess\_json\_utf@{guess\_json\_utf}}
\index{guess\_json\_utf@{guess\_json\_utf}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{guess\_json\_utf()}{guess\_json\_utf()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a5ab5bd841aa4c2f7f1de7116681fdc0b} 
requests.\+utils.\+guess\+\_\+json\+\_\+utf (\begin{DoxyParamCaption}\item[{}]{data}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a0032596bcde59652ed82002e1d2e54b6}\index{requests.utils@{requests.utils}!is\_ipv4\_address@{is\_ipv4\_address}}
\index{is\_ipv4\_address@{is\_ipv4\_address}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{is\_ipv4\_address()}{is\_ipv4\_address()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a0032596bcde59652ed82002e1d2e54b6} 
requests.\+utils.\+is\+\_\+ipv4\+\_\+address (\begin{DoxyParamCaption}\item[{}]{string\+\_\+ip}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}:rtype: bool
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_aaa928b4720b9ef7f9ac2bf782261f678}\index{requests.utils@{requests.utils}!is\_valid\_cidr@{is\_valid\_cidr}}
\index{is\_valid\_cidr@{is\_valid\_cidr}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{is\_valid\_cidr()}{is\_valid\_cidr()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_aaa928b4720b9ef7f9ac2bf782261f678} 
requests.\+utils.\+is\+\_\+valid\+\_\+cidr (\begin{DoxyParamCaption}\item[{}]{string\+\_\+network}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Very simple check of the cidr format in no_proxy variable.

:rtype: bool
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a736a580686e4c56ad9839e130e4e9275}\index{requests.utils@{requests.utils}!iter\_slices@{iter\_slices}}
\index{iter\_slices@{iter\_slices}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{iter\_slices()}{iter\_slices()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a736a580686e4c56ad9839e130e4e9275} 
requests.\+utils.\+iter\+\_\+slices (\begin{DoxyParamCaption}\item[{}]{string}{, }\item[{}]{slice\+\_\+length}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Iterate over slices of a string.\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_af138777b022e18c3a92b507b35fd0efb}\index{requests.utils@{requests.utils}!parse\_dict\_header@{parse\_dict\_header}}
\index{parse\_dict\_header@{parse\_dict\_header}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_dict\_header()}{parse\_dict\_header()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_af138777b022e18c3a92b507b35fd0efb} 
requests.\+utils.\+parse\+\_\+dict\+\_\+header (\begin{DoxyParamCaption}\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse lists of key, value pairs as described by RFC 2068 Section 2 and
convert them into a python dict:

>>> d = parse_dict_header('foo="is a fish", bar="as well"')
>>> type(d) is dict
True
>>> sorted(d.items())
[('bar', 'as well'), ('foo', 'is a fish')]

If there is no value for a key it will be `None`:

>>> parse_dict_header('key_without_value')
{'key_without_value': None}

To create a header from the :class:`dict` again, use the
:func:`dump_header` function.

:param value: a string with a dict header.
:return: :class:`dict`
:rtype: dict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ab50769584f88302aab3bad1bbbbc446a}\index{requests.utils@{requests.utils}!parse\_header\_links@{parse\_header\_links}}
\index{parse\_header\_links@{parse\_header\_links}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_header\_links()}{parse\_header\_links()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ab50769584f88302aab3bad1bbbbc446a} 
requests.\+utils.\+parse\+\_\+header\+\_\+links (\begin{DoxyParamCaption}\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return a list of parsed link headers proxies.

i.e. Link: <http:/.../front.jpeg>; rel=front; type="image/jpeg",<http://.../back.jpeg>; rel=back;type="image/jpeg"

:rtype: list
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ad3725c94c4c8a284639724d31808d720}\index{requests.utils@{requests.utils}!parse\_list\_header@{parse\_list\_header}}
\index{parse\_list\_header@{parse\_list\_header}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{parse\_list\_header()}{parse\_list\_header()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ad3725c94c4c8a284639724d31808d720} 
requests.\+utils.\+parse\+\_\+list\+\_\+header (\begin{DoxyParamCaption}\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse lists as described by RFC 2068 Section 2.

In particular, parse comma-separated lists where the elements of
the list may include quoted-strings.  A quoted-string could
contain a comma.  A non-quoted string could have quotes in the
middle.  Quotes are removed automatically after parsing.

It basically works like :func:`parse_set_header` just that items
may appear multiple times and case sensitivity is preserved.

The return value is a standard :class:`list`:

>>> parse_list_header('token, "quoted value"')
['token', 'quoted value']

To create a header from the :class:`list` again, use the
:func:`dump_header` function.

:param value: a string with a list header.
:return: :class:`list`
:rtype: list
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a13469939a631c81a773c8acb2fb9f363}\index{requests.utils@{requests.utils}!prepend\_scheme\_if\_needed@{prepend\_scheme\_if\_needed}}
\index{prepend\_scheme\_if\_needed@{prepend\_scheme\_if\_needed}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{prepend\_scheme\_if\_needed()}{prepend\_scheme\_if\_needed()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a13469939a631c81a773c8acb2fb9f363} 
requests.\+utils.\+prepend\+\_\+scheme\+\_\+if\+\_\+needed (\begin{DoxyParamCaption}\item[{}]{url}{, }\item[{}]{new\+\_\+scheme}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a URL that may or may not have a scheme, prepend the given scheme.
Does not replace a present scheme with the one provided as an argument.

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_afa6029e54432c133cf4b40e0083d93f7}\index{requests.utils@{requests.utils}!proxy\_bypass@{proxy\_bypass}}
\index{proxy\_bypass@{proxy\_bypass}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{proxy\_bypass()}{proxy\_bypass()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_afa6029e54432c133cf4b40e0083d93f7} 
requests.\+utils.\+proxy\+\_\+bypass (\begin{DoxyParamCaption}\item[{}]{host}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Return True, if the host should be bypassed.

Checks proxy settings gathered from the environment, if specified,
or the registry.
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a8c9fe3c9ac2bd12a800447169e0e0670}\index{requests.utils@{requests.utils}!requote\_uri@{requote\_uri}}
\index{requote\_uri@{requote\_uri}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{requote\_uri()}{requote\_uri()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a8c9fe3c9ac2bd12a800447169e0e0670} 
requests.\+utils.\+requote\+\_\+uri (\begin{DoxyParamCaption}\item[{}]{uri}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Re-quote the given URI.

This function passes the given URI through an unquote/quote cycle to
ensure that it is fully and consistently quoted.

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a0512e3f1e64d904b7e01e7fc8efcaf0d}\index{requests.utils@{requests.utils}!resolve\_proxies@{resolve\_proxies}}
\index{resolve\_proxies@{resolve\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{resolve\_proxies()}{resolve\_proxies()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a0512e3f1e64d904b7e01e7fc8efcaf0d} 
requests.\+utils.\+resolve\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{request}{, }\item[{}]{proxies}{, }\item[{}]{trust\+\_\+env}{ = {\ttfamily True}}\end{DoxyParamCaption})}

\begin{DoxyVerb}This method takes proxy information from a request and configuration
input to resolve a mapping of target proxies. This will consider settings
such as NO_PROXY to strip proxy configurations.

:param request: Request or PreparedRequest
:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
:param trust_env: Boolean declaring whether to trust environment configs

:rtype: dict
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a13215bbc71180ebbe86f99999bdd0b8c}\index{requests.utils@{requests.utils}!rewind\_body@{rewind\_body}}
\index{rewind\_body@{rewind\_body}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{rewind\_body()}{rewind\_body()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a13215bbc71180ebbe86f99999bdd0b8c} 
requests.\+utils.\+rewind\+\_\+body (\begin{DoxyParamCaption}\item[{}]{prepared\+\_\+request}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Move file pointer back to its recorded starting position
so it can be read again on redirect.
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_adf045a28323bbaaac6de35c6d69ba2cc}\index{requests.utils@{requests.utils}!select\_proxy@{select\_proxy}}
\index{select\_proxy@{select\_proxy}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{select\_proxy()}{select\_proxy()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_adf045a28323bbaaac6de35c6d69ba2cc} 
requests.\+utils.\+select\+\_\+proxy (\begin{DoxyParamCaption}\item[{}]{url}{, }\item[{}]{proxies}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Select a proxy for the url, if applicable.

:param url: The url being for the request
:param proxies: A dictionary of schemes or schemes and hosts to proxy URLs
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a5d285ca80bd58e70e828532e7d2f6ebf}\index{requests.utils@{requests.utils}!set\_environ@{set\_environ}}
\index{set\_environ@{set\_environ}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{set\_environ()}{set\_environ()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a5d285ca80bd58e70e828532e7d2f6ebf} 
requests.\+utils.\+set\+\_\+environ (\begin{DoxyParamCaption}\item[{}]{env\+\_\+name}{, }\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Set the environment variable 'env_name' to 'value'

Save previous value, yield, and then restore the previous value stored in
the environment variable 'env_name'.

If 'value' is None, do nothing\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a7be3a56db1500d1c5c79db4e8884a018}\index{requests.utils@{requests.utils}!should\_bypass\_proxies@{should\_bypass\_proxies}}
\index{should\_bypass\_proxies@{should\_bypass\_proxies}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{should\_bypass\_proxies()}{should\_bypass\_proxies()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a7be3a56db1500d1c5c79db4e8884a018} 
requests.\+utils.\+should\+\_\+bypass\+\_\+proxies (\begin{DoxyParamCaption}\item[{}]{url}{, }\item[{}]{no\+\_\+proxy}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Returns whether we should bypass proxies or not.

:rtype: bool
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ad8bca5e2a573cb2f2abd8b7ac931e693}\index{requests.utils@{requests.utils}!stream\_decode\_response\_unicode@{stream\_decode\_response\_unicode}}
\index{stream\_decode\_response\_unicode@{stream\_decode\_response\_unicode}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{stream\_decode\_response\_unicode()}{stream\_decode\_response\_unicode()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ad8bca5e2a573cb2f2abd8b7ac931e693} 
requests.\+utils.\+stream\+\_\+decode\+\_\+response\+\_\+unicode (\begin{DoxyParamCaption}\item[{}]{iterator}{, }\item[{}]{r}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Stream decodes an iterator.\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a6ea8cc24a110e6f447baef613013907f}\index{requests.utils@{requests.utils}!to\_key\_val\_list@{to\_key\_val\_list}}
\index{to\_key\_val\_list@{to\_key\_val\_list}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{to\_key\_val\_list()}{to\_key\_val\_list()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a6ea8cc24a110e6f447baef613013907f} 
requests.\+utils.\+to\+\_\+key\+\_\+val\+\_\+list (\begin{DoxyParamCaption}\item[{}]{value}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Take an object and test to see if it can be represented as a
dictionary. If it can be, return a list of tuples, e.g.,

::

    >>> to_key_val_list([('key', 'val')])
    [('key', 'val')]
    >>> to_key_val_list({'key': 'val'})
    [('key', 'val')]
    >>> to_key_val_list('string')
    Traceback (most recent call last):
    ...
    ValueError: cannot encode objects that are not 2-tuples

:rtype: list
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a38d24d784c3fdf1711d7d427fee93954}\index{requests.utils@{requests.utils}!unquote\_header\_value@{unquote\_header\_value}}
\index{unquote\_header\_value@{unquote\_header\_value}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{unquote\_header\_value()}{unquote\_header\_value()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a38d24d784c3fdf1711d7d427fee93954} 
requests.\+utils.\+unquote\+\_\+header\+\_\+value (\begin{DoxyParamCaption}\item[{}]{value}{, }\item[{}]{is\+\_\+filename}{ = {\ttfamily False}}\end{DoxyParamCaption})}

\begin{DoxyVerb}Unquotes a header value.  (Reversal of :func:`quote_header_value`).
This does not use the real unquoting but what browsers are actually
using for quoting.

:param value: the header value to unquote.
:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_a4f9754a15bf861194570d75e1863381b}\index{requests.utils@{requests.utils}!unquote\_unreserved@{unquote\_unreserved}}
\index{unquote\_unreserved@{unquote\_unreserved}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{unquote\_unreserved()}{unquote\_unreserved()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a4f9754a15bf861194570d75e1863381b} 
requests.\+utils.\+unquote\+\_\+unreserved (\begin{DoxyParamCaption}\item[{}]{uri}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Un-escape any percent-escape sequences in a URI that are unreserved
characters. This leaves all reserved, illegal and non-ASCII bytes encoded.

:rtype: str
\end{DoxyVerb}
 \Hypertarget{namespacerequests_1_1utils_ad5cd90b7dfae5b0d9809ef0d52ad1ff7}\index{requests.utils@{requests.utils}!urldefragauth@{urldefragauth}}
\index{urldefragauth@{urldefragauth}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{urldefragauth()}{urldefragauth()}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_ad5cd90b7dfae5b0d9809ef0d52ad1ff7} 
requests.\+utils.\+urldefragauth (\begin{DoxyParamCaption}\item[{}]{url}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Given a url remove the fragment and the authentication part.

:rtype: str
\end{DoxyVerb}
 

\doxysubsection{Variable Documentation}
\Hypertarget{namespacerequests_1_1utils_abcced58e9e5e747662c683f7a8a91678}\index{requests.utils@{requests.utils}!DEFAULT\_ACCEPT\_ENCODING@{DEFAULT\_ACCEPT\_ENCODING}}
\index{DEFAULT\_ACCEPT\_ENCODING@{DEFAULT\_ACCEPT\_ENCODING}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{DEFAULT\_ACCEPT\_ENCODING}{DEFAULT\_ACCEPT\_ENCODING}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_abcced58e9e5e747662c683f7a8a91678} 
str requests.\+utils.\+DEFAULT\+\_\+\+ACCEPT\+\_\+\+ENCODING}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ \textcolor{stringliteral}{"{},\ "{}}.join(}
\DoxyCodeLine{00002\ \ \ \ \ re.split(\textcolor{stringliteral}{r"{},\(\backslash\)s*"{}},\ make\_headers(accept\_encoding=\textcolor{keyword}{True})[\textcolor{stringliteral}{"{}accept-\/encoding"{}}])}
\DoxyCodeLine{00003\ )}

\end{DoxyCode}
\Hypertarget{namespacerequests_1_1utils_a06db2df65ac89013c3f98efa6d00bd1a}\index{requests.utils@{requests.utils}!UNRESERVED\_SET@{UNRESERVED\_SET}}
\index{UNRESERVED\_SET@{UNRESERVED\_SET}!requests.utils@{requests.utils}}
\doxysubsubsection{\texorpdfstring{UNRESERVED\_SET}{UNRESERVED\_SET}}
{\footnotesize\ttfamily \label{namespacerequests_1_1utils_a06db2df65ac89013c3f98efa6d00bd1a} 
requests.\+utils.\+UNRESERVED\+\_\+\+SET}

{\bfseries Initial value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ =\ \ frozenset(}
\DoxyCodeLine{00002\ \ \ \ \ \textcolor{stringliteral}{"{}ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"{}}\ +\ \textcolor{stringliteral}{"{}0123456789-\/.\_\string~"{}}}
\DoxyCodeLine{00003\ )}

\end{DoxyCode}
