\doxysection{dateutil.\+parser.\+\_\+parser Namespace Reference}
\hypertarget{namespacedateutil_1_1parser_1_1__parser}{}\label{namespacedateutil_1_1parser_1_1__parser}\index{dateutil.parser.\_parser@{dateutil.parser.\_parser}}
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1__resultbase}{\+\_\+resultbase}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1__timelex}{\+\_\+timelex}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1__tzparser}{\+\_\+tzparser}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1__ymd}{\+\_\+ymd}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1parser}{parser}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1_parser_error}{Parser\+Error}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1parserinfo}{parserinfo}}
\item 
class \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1_unknown_timezone_warning}{Unknown\+Timezone\+Warning}}
\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{namespacedateutil_1_1parser_1_1__parser_aa67caa4397ea2fb34df3859c790e34c1}{parse}} (timestr, \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1parserinfo}{parserinfo}}=None, \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}kwargs)
\item 
\Hypertarget{namespacedateutil_1_1parser_1_1__parser_aef6af4966f4f2c4a500aeff08a1b48f4}\label{namespacedateutil_1_1parser_1_1__parser_aef6af4966f4f2c4a500aeff08a1b48f4} 
{\bfseries \+\_\+parsetz} (tzstr)
\end{DoxyCompactItemize}
\doxysubsubsection*{Variables}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{namespacedateutil_1_1parser_1_1__parser_a8e75ff5e3f1593dc66f300731a663464}\label{namespacedateutil_1_1parser_1_1__parser_a8e75ff5e3f1593dc66f300731a663464} 
{\bfseries DEFAULTPARSER} = \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1parser}{parser}}()
\item 
\Hypertarget{namespacedateutil_1_1parser_1_1__parser_ac93cf0effa79f2c46ff007c2b4b105e9}\label{namespacedateutil_1_1parser_1_1__parser_ac93cf0effa79f2c46ff007c2b4b105e9} 
{\bfseries DEFAULTTZPARSER} = \mbox{\hyperlink{classdateutil_1_1parser_1_1__parser_1_1__tzparser}{\+\_\+tzparser}}()
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\begin{DoxyVerb}This module offers a generic date/time string parser which is able to parse
most known formats to represent a date and/or time.

This module attempts to be forgiving with regards to unlikely input formats,
returning a datetime object even for dates which are ambiguous. If an element
of a date/time stamp is omitted, the following rules are applied:

- If AM or PM is left unspecified, a 24-hour clock is assumed, however, an hour
  on a 12-hour clock (``0 <= hour <= 12``) *must* be specified if AM or PM is
  specified.
- If a time zone is omitted, a timezone-naive datetime is returned.

If any other elements are missing, they are taken from the
:class:`datetime.datetime` object passed to the parameter ``default``. If this
results in a day number exceeding the valid number of days per month, the
value falls back to the end of the month.

Additional resources about date/time string formats can be found below:

- `A summary of the international standard date and time notation
  <https://www.cl.cam.ac.uk/~mgk25/iso-time.html>`_
- `W3C Date and Time Formats <https://www.w3.org/TR/NOTE-datetime>`_
- `Time Formats (Planetary Rings Node) <https://pds-rings.seti.org:443/tools/time_formats.html>`_
- `CPAN ParseDate module
  <https://metacpan.org/pod/release/MUIR/Time-modules-2013.0912/lib/Time/ParseDate.pm>`_
- `Java SimpleDateFormat Class
  <https://docs.oracle.com/javase/6/docs/api/java/text/SimpleDateFormat.html>`_
\end{DoxyVerb}
 

\doxysubsection{Function Documentation}
\Hypertarget{namespacedateutil_1_1parser_1_1__parser_aa67caa4397ea2fb34df3859c790e34c1}\index{dateutil.parser.\_parser@{dateutil.parser.\_parser}!parse@{parse}}
\index{parse@{parse}!dateutil.parser.\_parser@{dateutil.parser.\_parser}}
\doxysubsubsection{\texorpdfstring{parse()}{parse()}}
{\footnotesize\ttfamily \label{namespacedateutil_1_1parser_1_1__parser_aa67caa4397ea2fb34df3859c790e34c1} 
dateutil.\+parser.\+\_\+parser.\+parse (\begin{DoxyParamCaption}\item[{}]{timestr}{, }\item[{}]{parserinfo}{ = {\ttfamily None}, }\item[{\texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}}]{kwargs}{}\end{DoxyParamCaption})}

\begin{DoxyVerb}Parse a string in one of the supported formats, using the
``parserinfo`` parameters.

:param timestr:
    A string containing a date/time stamp.

:param parserinfo:
    A :class:`parserinfo` object containing parameters for the parser.
    If ``None``, the default arguments to the :class:`parserinfo`
    constructor are used.

The ``**kwargs`` parameter takes the following keyword arguments:

:param default:
    The default datetime object, if this is a datetime object and not
    ``None``, elements specified in ``timestr`` replace elements in the
    default object.

:param ignoretz:
    If set ``True``, time zones in parsed strings are ignored and a naive
    :class:`datetime` object is returned.

:param tzinfos:
    Additional time zone names / aliases which may be present in the
    string. This argument maps time zone names (and optionally offsets
    from those time zones) to time zones. This parameter can be a
    dictionary with timezone aliases mapping time zone names to time
    zones or a function taking two parameters (``tzname`` and
    ``tzoffset``) and returning a time zone.

    The timezones to which the names are mapped can be an integer
    offset from UTC in seconds or a :class:`tzinfo` object.

    .. doctest::
       :options: +NORMALIZE_WHITESPACE

        >>> from dateutil.parser import parse
        >>> from dateutil.tz import gettz
        >>> tzinfos = {"BRST": -7200, "CST": gettz("America/Chicago")}
        >>> parse("2012-01-19 17:21:00 BRST", tzinfos=tzinfos)
        datetime.datetime(2012, 1, 19, 17, 21, tzinfo=tzoffset(u'BRST', -7200))
        >>> parse("2012-01-19 17:21:00 CST", tzinfos=tzinfos)
        datetime.datetime(2012, 1, 19, 17, 21,
                          tzinfo=tzfile('/usr/share/zoneinfo/America/Chicago'))

    This parameter is ignored if ``ignoretz`` is set.

:param dayfirst:
    Whether to interpret the first value in an ambiguous 3-integer date
    (e.g. 01/05/09) as the day (``True``) or month (``False``). If
    ``yearfirst`` is set to ``True``, this distinguishes between YDM and
    YMD. If set to ``None``, this value is retrieved from the current
    :class:`parserinfo` object (which itself defaults to ``False``).

:param yearfirst:
    Whether to interpret the first value in an ambiguous 3-integer date
    (e.g. 01/05/09) as the year. If ``True``, the first number is taken to
    be the year, otherwise the last number is taken to be the year. If
    this is set to ``None``, the value is retrieved from the current
    :class:`parserinfo` object (which itself defaults to ``False``).

:param fuzzy:
    Whether to allow fuzzy parsing, allowing for string like "Today is
    January 1, 2047 at 8:21:00AM".

:param fuzzy_with_tokens:
    If ``True``, ``fuzzy`` is automatically set to True, and the parser
    will return a tuple where the first element is the parsed
    :class:`datetime.datetime` datetimestamp and the second element is
    a tuple containing the portions of the string which were ignored:

    .. doctest::

        >>> from dateutil.parser import parse
        >>> parse("Today is January 1, 2047 at 8:21:00AM", fuzzy_with_tokens=True)
        (datetime.datetime(2047, 1, 1, 8, 21), (u'Today is ', u' ', u'at '))

:return:
    Returns a :class:`datetime.datetime` object or, if the
    ``fuzzy_with_tokens`` option is ``True``, returns a tuple, the
    first element being a :class:`datetime.datetime` object, the second
    a tuple containing the fuzzy tokens.

:raises ParserError:
    Raised for invalid or unknown string formats, if the provided
    :class:`tzinfo` is not in a valid format, or if an invalid date would
    be created.

:raises OverflowError:
    Raised if the parsed date exceeds the largest valid C integer on
    your system.
\end{DoxyVerb}
 